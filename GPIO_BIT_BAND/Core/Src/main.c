/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
/*Defines -------------------------------------------------------------------*/
/*
0x20000000 ==> Base address of SRAM
0x22000000 ==> Base address of SRAM alias region

0x40000000 ==> Base address of peripheral region
0x42000000 ==> Base address of peripheral alias region
*/

/*
// Define base address of bit-band
//#define BITBAND_SRAM_REF 		0x20000000
//#define BITBAND_SRAM_BASE 	0x22000000
//#define BITBAND_SRAM(a,b) 	((BITBAND_SRAM_BASE + (a-BITBAND_SRAM_REF)*32 \
//														+ (b*4))) // Convert SRAM address
//#define BITBAND_PERI_REF 		0x40000000
//#define BITBAND_PERI_BASE 	0x42000000
//#define BITBAND_PERI(a,b) 	((BITBAND_PERI_BASE + (a-BITBAND_PERI_REF)*32 \
//														+ (b*4))) // Convert PERI address
*/
#define BITBAND_PERI(a,b) 		((PERIPH_BB_BASE + (a - PERIPH_BASE)*32 + 4*b))
#define ODR_PD12				*((volatile unsigned char*)(BITBAND_PERI(GPIOD_BASE + 0x14, 12)))
#define IDR_PA0					*((volatile unsigned char*)(BITBAND_PERI(GPIOA_BASE + 0X10, 0)))
/*Typedef -------------------------------------------------------------------*/


/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);


int main(void)
{
	PLL_Config();
	printf("Ejemplo de manejo de pines\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();

    /* Loop forever */
	for(;;){
		if(IDR_PA0 == 1){
			ODR_PD12 = 1;
		}else{
			ODR_PD12 = 0;
		}
	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN | RCC_AHB1ENR_GPIOAEN;
	//->PA0 ENTRADA
	GPIOA->MODER &=~ GPIO_MODER_MODE0;			//INPUT FLOATING
	GPIOA->PUPDR &=~ GPIO_PUPDR_PUPD0;			//RESET (no pull up/down)
	//PD12->SALIDA
	GPIOD->MODER &=~ GPIO_MODER_MODE12;
	GPIOD->MODER |= GPIO_MODER_MODE12_0;		//SALIDA DE PROPOSITO GENERAL
	GPIOD->OTYPER &=~ GPIO_OTYPER_OT12;			//PUSH PULL
	GPIOD->OSPEEDR |= GPIO_OSPEEDR_OSPEED12;	//VERY HIGH SPEED
	GPIOD->PUPDR &=~ GPIO_PUPDR_PUPD12;			//RESET
}
/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
