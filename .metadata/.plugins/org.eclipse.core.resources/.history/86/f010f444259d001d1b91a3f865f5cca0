/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>

/*Typedef -------------------------------------------------------------------*/
typedef struct{
	volatile uint8_t idr0: 1;
	volatile uint8_t idr1: 1;
	volatile uint8_t idr2: 1;
	volatile uint8_t idr3: 1;
	volatile uint8_t idr4: 1;
	volatile uint8_t idr5: 1;
	volatile uint8_t idr6: 1;
	volatile uint8_t idr7: 1;
	volatile uint8_t idr8: 1;
	volatile uint8_t idr9: 1;
	volatile uint8_t idr10: 1;
	volatile uint8_t idr11: 1;
	volatile uint8_t idr12: 1;
	volatile uint8_t idr13: 1;
	volatile uint8_t idr14: 1;
	volatile uint8_t idr15: 1;
}IDR_bit_t;

/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);


int main(void)
{
	uint8_t state = 0;

	IDR_bit_t *IDRA = (IDR_bit_t *)&GPIOA->IDR;

	PLL_Config();
	printf("Ejemplo de manejo de pines\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();

    /* Loop forever */
	for(;;){
		//(GPIOA->IDR>>pin & 0x1)
		if(IDRA->idr0 == 1){
			printf("presionado\r\n");
			while(IDRA->idr0 == 1);
			printf("soltado\r\n");
			state += 1;
			//todo
			//GPIOD->ODR ^= GPIO_ODR_OD12;
		}
		switch(state){
		case 0: 		//espera
			//wait
			break;
		case 1: 		//encendido
			GPIOD->ODR |= GPIO_ODR_OD12;
			pritnf("led encendido\r\n");
			break;
		case 2:
			GPIOD->BSRR |= GPIO_BSRR_BR12;
			pritnf("led apagado\r\n");
			break;
		case 3:
			state = 0;
		}
	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN | RCC_AHB1ENR_GPIOAEN;
	//->PA0 ENTRADA
	GPIOA->MODER &=~ GPIO_MODER_MODE0;			//INPUT FLOATING
	GPIOA->PUPDR &=~ GPIO_PUPDR_PUPD0;			//RESET (no pull up/down)
	//PD12->SALIDA
	GPIOD->MODER &=~ GPIO_MODER_MODE12;
	GPIOD->MODER |= GPIO_MODER_MODE12_0;		//SALIDA DE PROPOSITO GENERAL
	GPIOD->OTYPER &=~ GPIO_OTYPER_OT12;			//PUSH PULL
	GPIOD->OSPEEDR |= GPIO_OSPEEDR_OSPEED12;	//VERY HIGH SPEED
	GPIOD->PUPDR &=~ GPIO_PUPDR_PUPD12;			//RESET
}
/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
