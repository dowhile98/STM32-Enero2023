/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include "defines.h"
#include "delay.h"
/*Defines -------------------------------------------------------------------*/

#define LED				D, 12
#define SW				A, 0
#define LED2			D, 13

#define ADC_IN1			1  	//PA1
#define ADC_IN2			2	//PA2
#define ADC_IN3			3	//PA3
#define IN1				A, 1
#define IN2				A, 2
#define IN3				A, 3
/*Typedef ------------------------------------------------------------------*/

/*Global variables ---------------------------------------------------------*/
float volt;
uint16_t adcval[3];

/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);

/**
 * @brief configuracion del ADC para conversion SINGLE
 */
void ADC1_Config(void);

/**
 * @brief configura los canales ADC utilizados
 */
void ADC1_CH_Config(void);
/**
 * @brief configurar el timer para disparar la conversion ADC
 * @param [freq] : frecuencia con lo que se realizará la conversion
 */
void TIM2_Config(uint32_t freq);

/**
 * @brief configuracion del stream correspondiente al ADC1
 */
void DMA2_Stream4_Config(void);
int main(void)
{
	PLL_Config();
	printf("Ejemplo de manejo de configuracion del DMA\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();
	//manejo se secciones criticas de codigo
	__disable_irq();
	SysTick_Init();
	__enable_irq();
	DMA2_Stream4_Config();
	ADC1_Config();
	ADC1_CH_Config();
	TIM2_Config(1);		//conversion cada 1s
    /* Loop forever */
	for(;;){

	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(SW);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, SW);
	GPIOX_PUPDR(MODE_PU_NONE, SW);
	GPIOX_MODER(MODE_OUT, LED2);
}


/**
 * @brief configuracion del ADC para conversion SINGLE
 */
void ADC1_Config(void){
	//1. habilitar el reloj
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN_Msk;
	//2. Configurar el prescaler del reloj del ADC
	ADC123_COMMON->CCR &=~ ADC_CCR_ADCPRE;
	ADC123_COMMON->CCR |= ADC_CCR_ADCPRE_0;		//PCLK2 / 4
	//3. Configurar la resolucion
	ADC1->CR1 = 0;
	ADC1->CR2 = 0;
//ADC1->CR1 |= ADC_CR1_RES_1;					//RES 12 BIT (0 - 4095)
	//configurar el disparo externo para la conversion
	ADC1->CR2 |= ADC_CR2_EXTEN_0;				//flanco ascendente
	ADC1->CR2 |= 0x6U<<ADC_CR2_EXTSEL_Pos;		//Timer2 TRIGO event (Update event)

	//habilitar el modo scan
	ADC1->CR1 |= ADC_CR1_SCAN;					//Habilita el modo scan
	//habilitar la peticiones de transferencia DMA
	ADC1->CR2 |= ADC_CR2_EOCS;
	ADC1->CR2 |= ADC_CR2_DDS;
	ADC1->CR2 |= ADC_CR2_DMA;				//DMA REQUEST FOR HW
	//4. encender el ADC
	ADC1->CR2 |= ADC_CR2_ADON;					//Enciende el ADC1 (Listo para conversiones)

	return;
}

void ADC1_CH_Config(void){
	//configurar los pines
	RCC->AHB1ENR |= GPIOX_CLOCK(IN1);
	GPIOX_MODER(MODE_ANALOG_INPUT, IN1);
	GPIOX_MODER(MODE_ANALOG_INPUT, IN2);
	GPIOX_MODER(MODE_ANALOG_INPUT, IN3);
	GPIOX_PUPDR(MODE_PU_NONE, IN1);
	GPIOX_PUPDR(MODE_PU_NONE, IN2);
	GPIOX_PUPDR(MODE_PU_NONE, IN3);
	//Configurar el tiempo de muestreo para cada canal
	ADC1->SMPR2 = 0;
	ADC1->SMPR2 &=~ ADC_SMPR2_SMP1;			//3 ciclos de muestreo
	ADC1->SMPR2 |= ADC_SMPR2_SMP2_0;		//15 ciclos de muestreo
	ADC1->SMPR2 |= ADC_SMPR2_SMP3_1;		//28 ciclos de muestreo
	//configurar la secuencia de conversion y la cantidad
	ADC1->SQR1 = (3- 1)<<ADC_SQR1_L_Pos;	//3 conversiones por secuencia
	ADC1->SQR3 = (ADC_IN1)<<ADC_SQR3_SQ1_Pos | (ADC_IN2)<<ADC_SQR3_SQ2_Pos | (ADC_IN3)<<ADC_SQR3_SQ3_Pos;
	return;
}
/**
 * @brief configurar el timer para disparar la conversion ADC
 * @param [freq] : frecuencia con lo que se realizará la conversion
 */
void TIM2_Config(uint32_t freq){

	uint32_t arr;
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	TIM2->CR1 = 0;
	/*Configura el PSC y ARR*/
	/**
	 * update event = Ftim/(PSC + 1)*(ARR + 1)
	 * PSC = 0;
	 * ARR = 168MHZ/(freq) - 1:
	 */
	arr = SystemCoreClock / freq - 1;
	TIM2->PSC = 0;
	TIM2->ARR = arr;
	TIM2->CR2 &=~ TIM_CR2_MMS;
	TIM2->CR2 |= TIM_CR2_MMS_1;		//updata event como salida TRGO
	TIM2->CR1 |= TIM_CR1_CEN;		//habilita el conteo
	return;
}
void DMA2_Stream4_Config(void){
	/*habilitar el reloj*/
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
	/*deshabilitar el stream*/
	DMA2_Stream4->CR &=~ DMA_SxCR_EN;
	while(DMA2_Stream4->CR & DMA_SxCR_EN);	//WAIT
	DMA2->HIFCR |= 0xF<<2 | 1U;				//clear para el stream 4
	/*Configurar la direccion PAR*/
	DMA2_Stream4->PAR = (uint32_t)&ADC1->DR;
	/*Configurar la direccion MAR*/
	DMA2_Stream4->M0AR = (uint32_t)adcval;
	/*numero de datos a transferirse*/
	DMA2_Stream4->NDTR = 3;
	/*seleccionar el canal*/
	DMA2_Stream4->CR &=~ DMA_SxCR_CHSEL;	//Se selecciona el channel 0
	/*configurar la prioridad del stream*/
	DMA2_Stream4->CR |= DMA_SxCR_PL;		//maxima prioridad
	/*configurar la FIFO*/
	DMA2_Stream4->FCR &=~ DMA_SxFCR_DMDIS;	//modo directo
	/*configurar la direccion de transferencia, el tamaño de los elementos y el incremento*/
	DMA2_Stream4->CR &=~ DMA_SxCR_MSIZE;
	DMA2_Stream4->CR |= DMA_SxCR_MSIZE_0;	//HALF-WORD (16BIT)
	DMA2_Stream4->CR &=~ DMA_SxCR_PSIZE;
	DMA2_Stream4->CR |= DMA_SxCR_PSIZE_0;	//HALF-WORD (16BIT)
	DMA2_Stream4->CR |= DMA_SxCR_MINC;		//memory increment mode
	DMA2_Stream4->CR |= DMA_SxCR_CIRC;		//modo circular
	/*10. configurar la interrupciones*/
	DMA2_Stream4->CR |= 1U<<4;
	NVIC_EnableIRQ(DMA2_Stream4_IRQn);
	DMA2_Stream4->FCR &=~ (DMA_SxFCR_FTH);
	//habilita el estream
	DMA2_Stream4->CR |= DMA_SxCR_EN;		//SE HABILITA EL STREAM
}
/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
