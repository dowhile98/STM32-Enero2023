/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include "defines.h"
#include "delay.h"
/*Defines -------------------------------------------------------------------*/

#define LED				D, 12
#define SW				A, 0
#define LED2			D, 13

#define I2C1_SCL		B, 6
#define I2C1_SDA 		B, 7

/*Typedef ------------------------------------------------------------------*/

/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);
/**
 * @brief configuracion del I2C1
 */
void I2C1_Config(void);


int main(void)
{
	PLL_Config();
	printf("Ejemplo de manejo de pines\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();
	//manejo se secciones criticas de codigo
	__disable_irq();
	SysTick_Init();
	__enable_irq();
    /* Loop forever */
	for(;;){

	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(SW);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, SW);
	GPIOX_PUPDR(MODE_PU_NONE, SW);
	GPIOX_MODER(MODE_OUT, LED2);
}

void I2C1_Config(void){
	uint32_t temp;
	//PINES
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SCL);		//Habilita el modo open drain
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SDA);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SCL);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, I2C1_SDA);//VERY HIGH SPEED
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);		//Habilita las resitencias pull up internas
	//I2C1
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//1. Reiniciar
	I2C1->CR1 |= I2C_CR1_SWRST;				//Renicia el I2C
	I2C1->CR1 &= I2C_CR1_SWRST;
	//2. Establecer el bit ack (solo va servir en caso de que el i2c1 reciba datos)
	I2C1->CR1 |= I2C_CR1_ACK;
	//3. Configurar la frecuencia
	/**
	 * PCLK1 = 42MHZ
	 *
	 */
	temp = 42;
	I2C1->CR2 = temp & 0x3FU;
	/**
	 * 4.Establecer el valor de CCR
	 *
	 */
	/**
	 * SM
	 * CCR = PCLK1 / (2 * 100000)
	 * FM
	 * DUTY = 0
	 * CCR = PCLK1 / (3 * 400000)
	 * CCR = 42E+6 / (3 * 400000)
	 * CCR = 35
	 * DUTY = 1
	 * CCR = PCLK1 / (25 * 400000)
	 */
	temp = 35;
	I2C1->CCR = temp & 0xFFFU;
	I2C1->CCR |= I2C_CCR_FS;
	/*5. Configurar el TRISE*/
	/**
	 * SM
	 * TRISE = PCLK1 / 1000000 + 1
	 * FS
	 * TRISE = (PCLK1 * 300) / (1000000000U) + 1
	 */
	temp = ((42E+6) * 300 ) /(1000000000U) + 1;
	I2C1->TRISE = temp;
	/*Opcional*/
	//configurar la direccion esclava del i2c1
	I2C1->OAR1 = 0x83;
	/*habilitar el I2C1*/
	I2C1->CR1 |= I2C_CR1_PE;

	return;
}

/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
