/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include "defines.h"
#include "delay.h"
#include <stdbool.h>
#include <string.h>


#include "lwrb.h"
/*Defines -------------------------------------------------------------------*/

#define LED				D, 12
#define SW				A, 0
#define LED2			D, 13



#define USART1_TX		B, 6
#define USART1_RX		B, 7
#define USART2_TX		A, 2
#define USART2_RX		A, 3

/**
 * Calculo de BRR
 */
#define UART_DIV_SAMPLING16(_PCLK_, _BAUD_)            ((uint32_t)((((uint64_t)(_PCLK_))*25U)/(4U*((uint64_t)(_BAUD_)))))
#define UART_DIVMANT_SAMPLING16(_PCLK_, _BAUD_)        (UART_DIV_SAMPLING16((_PCLK_), (_BAUD_))/100U)
#define UART_DIVFRAQ_SAMPLING16(_PCLK_, _BAUD_)        ((((UART_DIV_SAMPLING16((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) * 100U)) * 16U)\
                                                         + 50U) / 100U)
/* UART BRR = mantissa + overflow + fraction
            = (UART DIVMANT << 4) + (UART DIVFRAQ & 0xF0) + (UART DIVFRAQ & 0x0FU) */
#define UART_BRR_SAMPLING16(_PCLK_, _BAUD_)            ((UART_DIVMANT_SAMPLING16((_PCLK_), (_BAUD_)) << 4U) + \
                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0xF0U) + \
                                                        (UART_DIVFRAQ_SAMPLING16((_PCLK_), (_BAUD_)) & 0x0FU))

#define UART_DIV_SAMPLING8(_PCLK_, _BAUD_)             ((uint32_t)((((uint64_t)(_PCLK_))*25U)/(2U*((uint64_t)(_BAUD_)))))
#define UART_DIVMANT_SAMPLING8(_PCLK_, _BAUD_)         (UART_DIV_SAMPLING8((_PCLK_), (_BAUD_))/100U)
#define UART_DIVFRAQ_SAMPLING8(_PCLK_, _BAUD_)         ((((UART_DIV_SAMPLING8((_PCLK_), (_BAUD_)) - (UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) * 100U)) * 8U)\
                                                         + 50U) / 100U)
/* UART BRR = mantissa + overflow + fraction
            = (UART DIVMANT << 4) + ((UART DIVFRAQ & 0xF8) << 1) + (UART DIVFRAQ & 0x07U) */
#define UART_BRR_SAMPLING8(_PCLK_, _BAUD_)             ((UART_DIVMANT_SAMPLING8((_PCLK_), (_BAUD_)) << 4U) + \
                                                        ((UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0xF8U) << 1U) + \
                                                        (UART_DIVFRAQ_SAMPLING8((_PCLK_), (_BAUD_)) & 0x07U))

/*Typedef ------------------------------------------------------------------*/

/*Global variables ---------------------------------------------------------*/



uint8_t rxbuffer[10];

uint8_t data[100];
lwrb_t rbbuff = {0};
/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);

void USART1_Config(void);

void USART2_Config(void);



void rb_evt_fn(lwrb_t* buff, lwrb_evt_type_t type, size_t len);

bool at_verify_response(uint8_t *response,uint8_t *responsecheck, uint32_t timout);

void at_send_cmd(uint8_t *cmd, uint32_t timout);


int main(void)
{
	PLL_Config();
	//manejo se secciones criticas de codigo
	__disable_irq();
	SysTick_Init();
	__enable_irq();

	USART1_Config();
	delay_ms(1000);
	USART2_Config();
	printf("Ejemplo de manejo del puerto serial\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();

	//libreria para el buffer circular
	lwrb_init(&rbbuff, data, sizeof(data));
	lwrb_set_evt_fn(&rbbuff, rb_evt_fn);


	at_send_cmd((uint8_t*)"AT\r\n", 100);
	GPIOX_ODR(LED2)   = 1;
	if(at_verify_response((uint8_t*)"OK\r\n", 10000)){
		printf("el dispositivo respondio\r\n");
		delay_ms(100);
		//se lee la bateria
		at_send_cmd((uint8_t*)"AT$V?\r\n", 3000);
		delay_ms(500);
		lwrb_read(&rbbuff,rxbuffer,6);
		printf("la bateria es->%s", rxbuffer);
	}


	GPIOX_ODR(LED2)   = 0;
    /* Loop forever */
	for(;;){

	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(SW);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, SW);
	GPIOX_PUPDR(MODE_PU_NONE, SW);
	GPIOX_MODER(MODE_OUT, LED2);
}

void USART1_Config(void){
	//configurar los pines
	RCC->AHB1ENR |= GPIOX_CLOCK(USART1_TX);
	GPIOX_MODER(MODE_ALTER, USART1_TX);
	GPIOX_MODER(MODE_ALTER, USART1_RX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART1_TX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART1_RX);
	GPIOX_AFR(7, USART1_TX);
	GPIOX_AFR(7, USART1_RX);
	//configurar el USART1
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	USART1->CR1 = 0;

	/**
	 * USARTDIV = (PCLK / 8 * (2 -OVER8) * BAUD))
	 * USARTDIV = 84E+6 /(16 * 115200)
	 * USARTDIV = 45.572
	 * FRACTION
	 * MANTISA = 45
	 * B = 0.572 * 16  = 12.032 ~ 12
	 * FRACTION = 12
	 */
	USART1->BRR = (45<<4) | 12;
	USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;

	USART1->CR1 |= USART_CR1_UE;				//HABILITA EL PUERTO SERIAL

	return;
}

void USART2_Config(void){
	//configurar los pines
	RCC->AHB1ENR |= GPIOX_CLOCK(USART2_TX);
	GPIOX_MODER(MODE_ALTER, USART2_TX);
	GPIOX_MODER(MODE_ALTER, USART2_RX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART2_TX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART2_RX);
	GPIOX_AFR(7, USART2_TX);
	GPIOX_AFR(7, USART2_RX);
	//configurar el USART1
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;


	USART2->CR1 = 0;


	USART2->BRR = UART_BRR_SAMPLING16(42E+6, 9600);
	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;


	/*Habilitar las interrupciones*/
	USART2->CR1 |= USART_CR1_RXNEIE;
	NVIC_EnableIRQ(USART2_IRQn);

	USART2->CR1 |= USART_CR1_UE;				//HABILITA EL PUERTO SERIAL

	return;
}
/**************************************************/

int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	ITM_SendChar(ch);
	while(!(USART1->SR & USART_SR_TXE));
	USART1->DR = c;
	return ch;
}
