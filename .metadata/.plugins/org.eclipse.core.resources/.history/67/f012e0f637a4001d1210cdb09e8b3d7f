/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include "defines.h"
#include "delay.h"
#include <stdbool.h>
#include <string.h>

/*Defines -------------------------------------------------------------------*/

#define LED				D, 12
#define SW				A, 0
#define LED2			D, 13



#define USART1_TX		B, 6
#define USART1_RX		B, 7
/*Typedef ------------------------------------------------------------------*/
typedef struct{
	uint8_t led_state;
	uint32_t ticks;
	uint32_t blinktime;
}Led_uml_t;
typedef enum{
	LED_STATE_INIT = 0,
	LED_STATE_WAIT,
	LED_STATE_BLINK,
	LED_STATE_STOP
}LED_State_t;

typedef enum{
	SW_STATE_INIT = 0,
	SW_STATE_LOW,
	SW_STATE_HIGH,
	SW_STATE_DEBOUNCE
}SW_State_t;

typedef struct{
	uint8_t state;
	uint32_t debouncecount;
}SW_Data_t;
/*Global variables ---------------------------------------------------------*/
Led_uml_t led1 = {0};
SW_Data_t sw1 = {0};
uint32_t count;
uint8_t txt[100];
uint8_t rxbuffer[10];
/****************************************************************************/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

/**
 * @brief funcion que configura pines como entrada y salida
 */
void GPIO_Config(void);

void LED_UML_function(void);


void SW_UML_funtion(void);

void USART1_Config(void);

/**
 * funcion para enviar datos modo polling
 */
bool UART_SendData(USART_TypeDef *USARTx, uint8_t *pData, uint32_t len, uint32_t timout);


void USART_ReceiveData(USART_TypeDef * USARTx,uint8_t *pRxBuffer, uint32_t Size);


int main(void)
{
	PLL_Config();
	USART1_Config();

	printf("Ejemplo de manejo del puerto serial\r\n");
	printf("%s %s\r\n", __DATE__, __TIME__);
	GPIO_Config();
	//manejo se secciones criticas de codigo
	__disable_irq();
	SysTick_Init();
	__enable_irq();
	sprintf((char*)txt, "esto es una prueba de la funcion USART TX POLLING\r\n");
	if(UART_SendData(USART1, txt, strlen((char*)txt), 1000)){
		printf("envio correcto\r\n");
	}else{
		printf("error de envio\r\n");
	}
	printf("input: ");
	USART_ReceiveData(USART1, rxbuffer, 3);
	printf("%s",rxbuffer);
    /* Loop forever */
	for(;;){
		LED_UML_function();
		SW_UML_funtion();
	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}
/***********************************************************************/
void GPIO_Config(void){
	//HABILITAR EL RELOJ
	RCC->AHB1ENR |= GPIOX_CLOCK(LED) | GPIOX_CLOCK(SW);
	GPIOX_MODER(MODE_OUT, LED);
	GPIOX_MODER(MODE_DIGITAL_INPUT, SW);
	GPIOX_PUPDR(MODE_PU_NONE, SW);
	GPIOX_MODER(MODE_OUT, LED2);
}

void LED_UML_function(void){
	switch(led1.led_state){
	case LED_STATE_INIT:
		led1.ticks = GetTick();
		led1.led_state = LED_STATE_BLINK;
		led1.blinktime = 50;
		break;
	case LED_STATE_WAIT:
		if((GetTick() - led1.ticks)>= led1.blinktime){
			led1.ticks = GetTick();
			led1.led_state = LED_STATE_BLINK;
		}
		break;
	case LED_STATE_BLINK:
		GPIOX_ODR(LED) ^= 1;
		led1.led_state = LED_STATE_WAIT;
		break;
	}
	return;
}

void SW_UML_funtion(void){
	switch(sw1.state){
	case SW_STATE_INIT:
	{
		if(GPIOX_IDR(SW) == 1){
			sw1.state = SW_STATE_HIGH;
		}else{
			sw1.state = SW_STATE_LOW;
		}
		break;
	}
	case SW_STATE_HIGH:
		if(GPIOX_IDR(SW) == 0){				//low transition?
			sw1.state = SW_STATE_DEBOUNCE;
			sw1.debouncecount = GetTick();
		}
		break;
	case SW_STATE_LOW:
		if(GPIOX_IDR(SW) == 1){				//hihg transition?
			sw1.state = SW_STATE_DEBOUNCE;
			sw1.debouncecount = GetTick();
		}
		break;
	case SW_STATE_DEBOUNCE:
		if((GetTick() - sw1.debouncecount) >= 20){	// 20 mS debounce time over?
			if(GPIOX_IDR(SW) == 0){					// yes then check if input low
				sw1.state = SW_STATE_LOW;
				//pulso valido
				count++;
				printf("pulso valido: count: %lu\n", count);
				GPIOX_ODR(LED2) ^= 1;
			}else{
				sw1.state = SW_STATE_HIGH;
			}
		}
	}
}

void USART1_Config(void){
	//configurar los pines
	RCC->AHB1ENR |= GPIOX_CLOCK(USART1_TX);
	GPIOX_MODER(MODE_ALTER, USART1_TX);
	GPIOX_MODER(MODE_ALTER, USART1_RX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART1_TX);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, USART1_RX);
	GPIOX_AFR(7, USART1_TX);
	GPIOX_AFR(7, USART1_RX);
	//configurar el USART1
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

	USART1->CR1 = 0;

	/**
	 * USARTDIV = (PCLK / 8 * (2 -OVER8) * BAUD))
	 * USARTDIV = 84E+6 /(16 * 115200)
	 * USARTDIV = 45.572
	 * FRACTION
	 * MANTISA = 45
	 * B = 0.572 * 16  = 12.032 ~ 12
	 * FRACTION = 12
	 */
	USART1->BRR = (45<<4) | 12;
	USART1->CR1 |= USART_CR1_TE | USART_CR1_RE;

	USART1->CR1 |= USART_CR1_UE;				//HABILITA EL PUERTO SERIAL

	return;
}

bool UART_SendData(USART_TypeDef *USARTx, uint8_t *pData, uint32_t len, uint32_t timout){
	bool state = false;
	uint8_t state_usart = 0;
	uint32_t tickstart = GetTick();
	uint16_t *ptr;
	while(len>0){
		switch(state_usart){
		case 0:					//verificar si la bander TXE esta
			if(USARTx->SR & USART_SR_TXE){
				state_usart = 1;
			}
			break;
		case 1:					//verificacion de la longitud de datos a transmitir
			if(USARTx->CR1 & USART_CR1_M){	//9bit
			 state_usart = 2;
			}else{// 8bit de datos
				state_usart = 3;
			}
			break;
		case 2:
			ptr = (uint16_t*)pData;
			USARTx->DR = (*ptr & (uint16_t)0x1FF);
			//se verifica la paridad
			if(USARTx->CR1 & USART_CR1_PCE){			//PARIDAD
				pData++;
				len--;
			}else{
				pData++;
				pData++;
				len -= 2;
			}
			state_usart = 0;
			break;
		case 3:
			USARTx->DR = (*pData);
			pData++;
			state_usart = 0;
			len--;
			break;
		}

		//SE VERIFICA EL TIMOUT
		if((GetTick() - tickstart)>timout){
			state = false;
			break;
		}else{
			state = true;
		}
	}
	return state;
}

/**
 * @brief enviar N data por el USART
 */
void USART_ReceiveData(USART_TypeDef * USARTx,uint8_t *pRxBuffer, uint32_t Size){
	for(uint32_t i= 0; i<Size;i++){
		//verificar el flag RXNE
		while(!(USARTx->SR & USART_SR_RXNE));
		//verificar si se va recibir en modo de 8bit o 9bit
		if(USARTx->CR1 & USART_CR1_M){

			/*VERIFICAR LA PARIDAD*/
			if(!(USARTx->CR1 & USART_CR1_PCE )){	//sin paridad
				*((uint16_t*) pRxBuffer) = USARTx->DR & (uint16_t) 0x1FF;
				pRxBuffer++;
				pRxBuffer++;
			}
			else{	//paridad
				*pRxBuffer = USARTx->DR & (uint8_t) 0xFF;
				pRxBuffer++;
			}
		}
		else{
			/*VERIFICAR LA PARIDAD*/
			if(!(USARTx->CR1 & USART_CR1_PCE)){
				*pRxBuffer = USARTx->DR & (uint8_t) 0xFF;
			}
			else{
				*pRxBuffer = USARTx->DR & (uint8_t) 0x7F;
			}
			pRxBuffer++;
		}
	}
	return;
}
/**************************************************/

int __io_putchar(int ch){
	uint8_t c = ch & 0xFF;
	ITM_SendChar(ch);
	while(!(USART1->SR & USART_SR_TXE));
	USART1->DR = c;
	return ch;
}
